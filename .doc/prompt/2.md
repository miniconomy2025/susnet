I have the following MongoDB schema for a Reddit clone I'm building:
[Typegoose schema](/server/db/schema.ts)


I have defined the following endpoint request/response type schemas:

[Generic types](/types/types.ts)
[API endpoint types](/types/api.ts)

My endpoint scaffolding system works as follows:
```ts
const router = express.Router();

for(const [route, handler] of Object.entries(endpoints)) {
  const [method, path] = route.split('|');

  router[method.toLowerCase() as 'get' | 'post' | 'patch' | 'delete'](path, async (req: Request, res: Response) => {
    try {
      console.log("\x1b[93mREQUEST:\x1b[0m", req.method, req.path);

      const result = await handler({ ...req.body, ...req.params }, req.user);
      res.json(result);
    }
    catch (err) {
      console.error("\x1b[91mERROR\x1b[0m:", err);
      res.json({
        success: false,
        error: 'internalError',
        message: String(err)
      })
    }
  });
}
```

The following utility functions are also available:
```ts
type AuthUser = AuthenticatedRequest["user"];
// type AuthUser = { id: Types.ObjectId; name: string };

function toActorDataSimple(doc: any): ActorData<'simple'> {
  return {
    name: doc.name,
    type: doc.type,
    thumbnailUrl: doc.thumbnailUrl,
    description: doc.description,
    origin: doc.origin
  };
}
function toActorDataFull(doc: any): ActorData<'full'> {
  return {
    ...toActorDataSimple(doc),
    postCount: doc.postCount,
    followerCount: doc.followerCount,
    followingCount: doc.followingCount,
  };
}

function toPostDataSimple(doc: any): PostData<'simple'> {
  return {
    postId: doc.postId,
    actorName: doc.actorName,
    subName: doc.subName,
    title: doc.title,
    content: doc.content,
    attachments: doc.attachments.map((a: any) => ({ ...a, _id: undefined})),
    tags: doc.tags,
  };
}
function toPostDataFull(doc: any): PostData<'full'> {
  return {
    ...toPostDataSimple(doc),
    upvotes: doc.upvotes,
    downvotes: doc.downvotes,
    score: doc.score,
  };
}

async function getActorObjId(name: string): Promise<Types.ObjectId | null> {
  const doc = await ActorModel.findOne({ name }).lean().exec();
  return doc?._id ?? null;
}

async function getPostObjId(postId: string): Promise<Types.ObjectId | null> {
  const doc = await PostModel.findOne({ postId }).lean().exec();
  return doc?._id ?? null;
}
```


Fix the below endpoint definition to return the list of followers for a given actor, by aggregating all the follower ActorData in a single query. At the moment it's just using the ObjectId ref directly, but this needs to be replaced with an object that contains all the necessary values to construct the ActorData.

```ts
const endpoints = {
    'GET|/actors/:name/followers': async ({ name }: { name: string }): Promise<Res_followers> => {
    const actorId = await getActorObjId(name);
    if (actorId == null) return { success: false, error: 'notFound' };

    const docs = await FollowModel.find({ targetRef: actorId })
      .populate('follower')
      .lean()
      .exec();
    return { success: true, followers: docs.map(f => toActorDataSimple(f.followerRef)) }; // TODO: Fix
  },
}
```